<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Course 3D - Route Large & Perspective Fuyante</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute; bottom: 30px; left: 30px; color: #00ff00;
            pointer-events: none; text-shadow: 2px 2px #000;
        }
        .speed-val { font-size: 48px; display: block; }
        .hint { color: #fff; font-size: 14px; }
    </style>
</head>
<body>

    <div id="ui">
        <span class="hint">FLÈCHES POUR PILOTER</span>
        <span id="speedDisplay" class="speed-val">000</span>
        <span>KM/H</span>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 1. CONFIGURATION DE LA SCÈNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 20, 150); // Brouillard pour l'effet de fuite

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. DÉFINITION DE LA ROUTE LARGE (50 UNITÉS) ---
        const rayonInterieur = 30;
        const largeurRoute = 50;
        const rayonExterieur = rayonInterieur + largeurRoute;
        const rayonMilieu = rayonInterieur + (largeurRoute / 2); // 55

        // Sol (Décor lointain)
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(2000, 2000),
            new THREE.MeshBasicMaterial({ color: 0x0a0a0a })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Grille de sol pour accentuer la sensation de mouvement
        const gridHelper = new THREE.GridHelper(1000, 100, 0x444444, 0x222222);
        gridHelper.position.y = -0.01;
        scene.add(gridHelper);

        // La Route Goudronnée
        const trackGeo = new THREE.RingGeometry(rayonInterieur, rayonExterieur, 128);
        const trackMat = new THREE.MeshBasicMaterial({ color: 0x222222, side: THREE.DoubleSide });
        const track = new THREE.Mesh(trackGeo, trackMat);
        track.rotation.x = -Math.PI / 2;
        track.position.y = 0.01;
        scene.add(track);

        // Ligne Centrale Jaune
        const lineGeo = new THREE.RingGeometry(rayonMilieu - 0.2, rayonMilieu + 0.2, 128);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, side: THREE.DoubleSide });
        const line = new THREE.Mesh(lineGeo, lineMat);
        line.rotation.x = -Math.PI / 2;
        line.position.y = 0.02;
        scene.add(line);

        // Vibreurs Extérieurs (Rouge et Blanc)
        const borderGeo = new THREE.RingGeometry(rayonExterieur, rayonExterieur + 1.5, 128);
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.rotation.x = -Math.PI / 2;
        border.position.y = 0.015;
        scene.add(border);

        // --- 3. LA VOITURE DU JOUEUR ---
        const carGroup = new THREE.Group();
        const carBody = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.6, 2.5),
            new THREE.MeshBasicMaterial({ color: 0xff0000 })
        );
        const carRoof = new THREE.Mesh(
            new THREE.BoxGeometry(1.2, 0.5, 1.2),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        carRoof.position.y = 0.5;

        // Feux arrière (pour l'effet vue arrière)
        const tailLightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const tailLightMat = new THREE.MeshBasicMaterial({ color: 0xaa0000 });
        const lLight = new THREE.Mesh(tailLightGeo, tailLightMat);
        lLight.position.set(-0.5, 0, -1.25);
        const rLight = lLight.clone();
        rLight.position.set(0.5, 0, -1.25);
        
        carGroup.add(carBody, carRoof, lLight, rLight);

        // Positionner au départ sur le milieu de la route
        carGroup.position.set(rayonMilieu, 0.3, 0);
        scene.add(carGroup);

        // --- 4. SYSTÈME DE CONDUITE ---
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        window.onkeydown = (e) => keys[e.code] = true;
        window.onkeyup = (e) => keys[e.code] = false;

        let velocity = 0;
        let rotation = 0;
        const friction = 0.98;
        const acceleration = 0.015;

        function updatePhysics() {
            // Accélération et Freinage
            if (keys.ArrowUp) velocity += acceleration;
            if (keys.ArrowDown) velocity -= acceleration;
            
            velocity *= friction;

            // Direction (proportionnelle à la vitesse)
            if (Math.abs(velocity) > 0.01) {
                const turnSpeed = 0.04;
                if (keys.ArrowLeft) rotation += turnSpeed * (velocity * 1.2);
                if (keys.ArrowRight) rotation -= turnSpeed * (velocity * 1.2);
            }

            // Mise à jour position
            carGroup.rotation.y = rotation;
            carGroup.position.x += Math.sin(rotation) * velocity;
            carGroup.position.z += Math.cos(rotation) * velocity;

            // --- 5. PERSPECTIVE FUYANTE (CAMERA) ---
            // On place la caméra derrière (8 unités) et un peu au-dessus (3 unités)
            const relativeCameraOffset = new THREE.Vector3(0, 3, -8);
            const cameraOffset = relativeCameraOffset.applyMatrix4(carGroup.matrixWorld);

            camera.position.lerp(cameraOffset, 0.1); // Suivi fluide
            
            // La caméra regarde loin devant la voiture (point de fuite)
            const lookTarget = new THREE.Vector3(
                carGroup.position.x + Math.sin(rotation) * 20,
                1,
                carGroup.position.z + Math.cos(rotation) * 20
            );
            camera.lookAt(lookTarget);

            // Affichage vitesse
            const speedKm = Math.round(Math.abs(velocity * 450));
            const speedElement = document.getElementById('speedDisplay');
            if(speedElement) speedElement.innerText = speedKm.toString().padStart(3, '0');
        }

        // --- 6. BOUCLE DE RENDU ---
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        // Gestion du redimensionnement
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        animate();
    </script>
</body>
</html>